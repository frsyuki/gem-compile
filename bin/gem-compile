#!/usr/bin/env ruby
#
# gem-compile
#
# Copyright (c) 2010 FURUHASHI Sadayuki
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
require 'optparse'
require 'fileutils'

args = ARGV.dup

if ARGV.include?('--')
	build_args = args[args.index("--") + 1...args.length]
	args = args[0...args.index("--")]
end

config = {
	:platform => nil,
	:fat => nil,
}

op = OptionParser.new
op.on('-p', '--platform PLATFORM',
			'Output platform name') {|s| config[:platform] = s }
op.on('-f', '--fat VERSION:RUBY,...',
			'Create fat binary (e.g. --fat 1.8:ruby,1.9:ruby19)') {|s| config[:fat] = s }

op.banner += " GEMFILE -- --build-flags"

op.parse!(args)

if args.length != 1
	puts op.to_s
	exit 0
end


require 'rubygems/format'
require 'rubygems/ext'
require 'rubygems/builder'
require 'shellwords'

Gem::Command.build_args = build_args if build_args

gem = args.first
platform = config[:platform] || Gem::Platform::CURRENT
fat = config[:fat]


gem_dir = "#{File.basename(gem)}.build"
gem_dir = File.expand_path(gem_dir)

begin
	format = Gem::Format.from_file_by_path(gem)
rescue => ex
	puts ex
	exit 1
end

spec = format.spec

if spec.extensions.empty?
	puts "There are no extensions to build."
	exit 1
end

if spec.platform != Gem::Platform::RUBY
	puts "The package seems to be built already."
	exit 1
end

fat_commands = {}
if fat
	fat.split(',').each do |ver_cmd|
		ver, cmd = ver_cmd.split(':', 2)
		unless ver =~ /^\d+\.\d+$/
			puts "Invalid version string #{ver.dump}"
			exit 1
		end
		fat_commands[ver] = cmd
	end
end

format.file_entries.each do |entry, file_data|
	path = entry['path'].untaint
	path = File.expand_path File.join(gem_dir, path)

	FileUtils.rm_rf(path) if File.exists?(path)
	FileUtils.mkdir_p File.dirname(path)

	File.open(path, "wb") do |out|
		out.write file_data
	end

	FileUtils.chmod entry['mode'], path

	puts path
end

ran_rake = false
start_dir = Dir.pwd
built_paths = []

spec.extensions.each do |extension|
	break if ran_rake
	results = []

	builder = case extension
						when /extconf/ then
							Gem::Ext::ExtConfBuilder
						when /configure/ then
							Gem::Ext::ConfigureBuilder
						when /rakefile/i, /mkrf_conf/i then
							ran_rake = true
							Gem::Ext::RakeBuilder
						else
							results = ["No builder for extension '#{extension}'"]
							raise results.last
						end

	begin
		dest_path = File.join(gem_dir, File.dirname(extension))
		extension = File.expand_path(extension)
		Dir.chdir dest_path

		if fat_commands.empty?
			results = builder.build(extension, gem_dir, dest_path, results)

			built_paths.concat Dir.glob("#{dest_path}/**/*")

		else
			ext_files = []

			fat_commands.each_pair do |version, command|
				version_path = File.join(dest_path, version)

				script = <<-EOF
require 'rubygems/ext'
puts #{builder}.build(#{extension.dump},#{gem_dir.dump},#{version_path.dump}, [])
				EOF

				result = `#{command} -e #{Shellwords.escape script}`
				results << result
				if $? != 0
					raise result
				end

				paths = Dir.glob("#{version_path}/**/*")
				files = paths.map {|path| path[File.join(version_path,'').length..-1] }
				ext_files.concat files

				built_paths.concat paths
			end

			ext_files.uniq.each do |ext_name|
				ext_basename = ext_name.sub(/\.[^\.]*$/, '')
				rb_path = File.join(dest_path, "#{ext_basename}.rb")
				File.open(rb_path, "w") do |f|
					f.write <<-EOF
require File.join File.dirname(__FILE__), RUBY_VERSION.match(/\\d+\\.\\d+/)[0], #{ext_basename.dump}
					EOF
				end

				built_paths << rb_path
			end

		end

		puts results.join("\n")

	rescue => ex
		results = results.join "\n"

		File.open('gem_make.out', 'wb') {|f| f.puts results }

		message = <<-EOF
ERROR: Failed to build gem native extension.

#{results}

Results logged to #{File.join(Dir.pwd, 'gem_make.out')}
		EOF

		puts message
	ensure
		Dir.chdir start_dir
	end

end
	
spec.extensions = []

built_files = built_paths.map {|path| path[File.join(gem_dir,'').length..-1] }
built_files.reject! {|path| path =~ /\.o$/ }  # FIXME

spec.files = (spec.files + built_files).sort.uniq
spec.platform = platform if platform

Dir.chdir gem_dir
out_fname = Gem::Builder.new(spec).build

FileUtils.mv(out_fname, start_dir)

